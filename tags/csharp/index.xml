<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>csharp on Yowko&#39;s Notes</title><link>https://blog.yowko.com/tags/csharp/</link><description>Recent content in csharp on Yowko&#39;s Notes</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 28 Jul 2021 21:30:00 +0800</lastBuildDate><atom:link href="https://blog.yowko.com/tags/csharp/index.xml" rel="self" type="application/rss+xml"/><item><title>HttpClient 使用 Polly 做 Timeout 重試</title><link>https://blog.yowko.com/httpclient-polly-timeout-retry/</link><pubDate>Wed, 28 Jul 2021 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/httpclient-polly-timeout-retry/</guid><description>HttpClient 使用 Polly 做 Timeout 重試 之前使用 HttpClient 做了一個內部的網頁回應偵測工具，原本沒有調整預設的 Timeout 時間 (預設為 100,000 毫秒 = 100 秒，相關說明可以參考 Microsoft docs:HttpClient.Timeout 屬性)，為了更即</description></item><item><title>使用 HttpClient 傳送檔案</title><link>https://blog.yowko.com/httpclient-file/</link><pubDate>Tue, 27 Jul 2021 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/httpclient-file/</guid><description>使用 HttpClient 傳送檔案 最近專案有個需求要將系統畫面 透過 RESTFul API 傳給其他平台做紀錄，這才發現這功能雖然過去待在專案公司時常做，但時間一久覺得好陌生，猛然發</description></item><item><title>HttpClient 使用 URL Parameters (Query Strings) 的方式</title><link>https://blog.yowko.com/httpclient-url-parameter/</link><pubDate>Sat, 24 Jul 2021 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/httpclient-url-parameter/</guid><description>HttpClient 使用 URL Parameters (Query Strings) 的方式 前陣子有個跟其他系統介接的需求，因為手上工作太滿，先由前端的同事使用 Node.js 開發，過陣子再接手改用 C# 開發；其中有個功能需要 post 幾</description></item><item><title>讓特定 message 在 kafka 中可以有順序性</title><link>https://blog.yowko.com/kafka-message-immutable-sequence/</link><pubDate>Sat, 25 Jul 2020 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/kafka-message-immutable-sequence/</guid><description>讓特定 message 在 kafka 中可以有順序性 之前專案為了保證 message 的順序性捨棄當時還在 0.8 版的 kafka 而選用 RabbitMQ，雖然 RabbitMQ 在效能數據上跟 kafka 不是同個量級水準，但已</description></item><item><title>[C#] 將 .NET Core 中的 Configuration 輸出為 JSON</title><link>https://blog.yowko.com/configuration-to-json/</link><pubDate>Sat, 08 Feb 2020 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/configuration-to-json/</guid><description>[C#] 將 .NET Core 中的 Configuration 輸出為 JSON 之前筆記 [C#] 將 Dictionary 轉為 JSON 紀錄到 將 Dictionary 轉為 JSON 的方式，對 .NET Core 有些認識的朋友馬上就想到是為了處理 .NET Core Configuration，主</description></item><item><title>[C#] 將 Dictionary 轉為 JSON</title><link>https://blog.yowko.com/dictionary-to-json/</link><pubDate>Sun, 02 Feb 2020 14:30:00 +0800</pubDate><guid>https://blog.yowko.com/dictionary-to-json/</guid><description>[C#] 將 Dictionary 轉為 JSON 之前筆記 [C#] 將 JSON 轉為 Dictionary 紀錄到如果將 JSON file 轉為 C# 的 Dictionary 來做後續加工處理，當然有 JSON to Dictionary 就需要有 Dictionary to JSON 囉 基本環境說明 macOS Catalina 10.15.2 .NET Core SDK 3.1.101 C# 8.0 程式碼</description></item><item><title>[C#] 將 JSON 轉為 Dictionary</title><link>https://blog.yowko.com/json-to-dictionary/</link><pubDate>Sat, 01 Feb 2020 14:30:00 +0800</pubDate><guid>https://blog.yowko.com/json-to-dictionary/</guid><description>[C#] 將 JSON 轉為 Dictionary 使用 JSON 做為避免在程式中寫死固定值的解決方案是種常見做法，不過一旦系統日漸龐大複雜起來時，可能就需要有良好的管理方式或是流程，像是</description></item><item><title>C# 使用 Lua 取得 Redis 自訂複雜型別</title><link>https://blog.yowko.com/csharp-lua-redis-custom-type/</link><pubDate>Mon, 09 Dec 2019 22:30:00 +0800</pubDate><guid>https://blog.yowko.com/csharp-lua-redis-custom-type/</guid><description>C# 使用 Lua 取得 Redis 自訂複雜型別 之前筆記 在 Redis 中使用 Lua 的 Dictionary 紀錄到在 Redis 中使用 Lua 時可以如何模擬並使用 Dictionary，而筆記最後也提到透過這樣的方式</description></item><item><title>C# - Property 與 Value 的 Dictionary 轉為 Object</title><link>https://blog.yowko.com/property-value-dictionary-to-object/</link><pubDate>Mon, 09 Dec 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/property-value-dictionary-to-object/</guid><description>C# - Property 與 Value 的 Dictionary 轉為 Object 之前筆記 C# - 將 Object 的 Property 與 Value 轉換為 Dictionary 紀錄到將 C# object 的 property name 與 value 透過 dictionary 的資料型態存放，當時主要是為了配合 InfluxDB 的 insert 而做的筆記 ，想不到時</description></item><item><title>Polly retry 之後的行為是？</title><link>https://blog.yowko.com/polly-after-retry/</link><pubDate>Sun, 01 Dec 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/polly-after-retry/</guid><description>Polly retry 之後的行為是？ 同事在追查 bug 時，問到在執行某個動作時使用的 Polly policy 來進行失敗重試，如果 policy 中設定的 retry 次數結束仍然失敗會發生什麼事？ 印象中之前測試</description></item><item><title>C# (.NET Core 2) 啟用 gRPC 壓縮</title><link>https://blog.yowko.com/dotnet-core-2-grpc-compression/</link><pubDate>Sat, 16 Nov 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/dotnet-core-2-grpc-compression/</guid><description>C# (.NET Core 2) 啟用 gRPC 壓縮 目前專案在大資料量傳遞時會透過 gRPC stream，不過因為是非對稱式資料內容，採用 chunk byte 來傳輸，以避免單次 gRPC 的 message size 限制問題，但以</description></item><item><title>C# (.NET Core 2) Log 與 Trace gRPC</title><link>https://blog.yowko.com/dotnet-core-2-log-grpc/</link><pubDate>Tue, 12 Nov 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/dotnet-core-2-log-grpc/</guid><description>C# (.NET Core 2) Log 與 Trace gRPC gRPC 在 .NET Core 3 被官方宣告重點發展項目之一，而身為追求系統更快更好又愛嚐鮮的工程師團隊的一員，早在一年前的 .NET Core 2 專案中就用上了 gR</description></item><item><title>[Benchmark] 使用 C# 對 InfluxDB insert 操作的效能數據</title><link>https://blog.yowko.com/csharp-influxdb-benchmark/</link><pubDate>Sun, 22 Sep 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/csharp-influxdb-benchmark/</guid><description>[Benchmark] 使用 C# 對 InfluxDB insert 操作的效能數據 之前筆記 使用 C# 存取 InfluxDB 紀錄了 C# 在 InfluxDB 的基本 CRUD，也提到新專案可能會使用 InfluxDB 儲存資料，在了解 C# 的基本用法後接著就來確</description></item><item><title>C# - 將 Object 的 Property 與 Value 轉換為 Dictionary</title><link>https://blog.yowko.com/csharp-object-to-dictionary/</link><pubDate>Sat, 21 Sep 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/csharp-object-to-dictionary/</guid><description>C# - 將 Object 的 Property 與 Value 轉換為 Dictionary 之前筆記 使用 C# 存取 InfluxDB 提到正在嘗試導入 InfluxDB，POC 使用到的 library - InfluxData.Net 在儲存資料時僅接受 Dictionary，如</description></item><item><title>需要在 return 前自行 new ValueTask 嗎？</title><link>https://blog.yowko.com/new-valuetask-or-not/</link><pubDate>Sun, 11 Aug 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/new-valuetask-or-not/</guid><description>需要在 return 前自行 new ValueTask 嗎？ 上個月黑大的 閱讀筆記 - 使用 .NET Async/Await 的常見錯誤 跟同事討論起 ValueTask 的用法，大意是 ValueTask 在使用上只需要將方法簽章改為 ValueTask&amp;lt;T&amp;gt; 就好嗎？ 還是應該在</description></item><item><title>Test 中驗證 Object 是否相同的方法</title><link>https://blog.yowko.com/object-compare-in-test/</link><pubDate>Tue, 23 Jul 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/object-compare-in-test/</guid><description>Test 中驗證 Object 是否相同的方法 最近花了不少時間在重構先前專案中的 Unit Test 與 Integration Test，其中對於 reference type 的物件比對有幾種不同的寫法 當然我個人大多配合團隊規範</description></item><item><title>gRPC stream 如何傳送單一大物件</title><link>https://blog.yowko.com/grpc-stream-big-object/</link><pubDate>Sun, 07 Jul 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/grpc-stream-big-object/</guid><description>gRPC stream 如何傳送單一大物件 之前筆記 C# 搭配 gRPC 中使用 stream RPC 提到為了對於較大資料量以及即時性資料內容，可以透過 gRPC 的 stream RPC 來處理，不過官方範例是用在傳送 repeated 內</description></item><item><title>C# 中使用 Protocol Buffers 協定來序列化與反序列化物件</title><link>https://blog.yowko.com/csharp-protobuf-serialize-deserialize/</link><pubDate>Sat, 06 Jul 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/csharp-protobuf-serialize-deserialize/</guid><description>C# 中使用 Protocol Buffers 協定來序列化與反序列化物件 專案上剛好需要將 object 進行序列化，過去常用的方式都是序列為 json，後來同事覺得既然都使用 protobuf 了，為什麼不直</description></item><item><title>gRPC 出現 `8 RESOURCE_EXHAUSTED` 錯誤</title><link>https://blog.yowko.com/grpc-8-resource-exhausted/</link><pubDate>Sun, 23 Jun 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/grpc-8-resource-exhausted/</guid><description>gRPC 出現 8 RESOURCE_EXHAUSTED 錯誤 隨著系統一步步成形，資料量也愈來愈大，在原本只是先求功能正常而未進行資料分頁的功能逐漸露出原型，今天就來筆記 gRPC 在傳送龐大資料可</description></item><item><title>嘗試為gRPC 中的 stream RPC 加上 Unit Test</title><link>https://blog.yowko.com/csharp-grpc-stream-unit-test/</link><pubDate>Wed, 19 Jun 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/csharp-grpc-stream-unit-test/</guid><description>嘗試為gRPC 中的 stream RPC 加上 Unit Test 之前筆記 C# 搭配 gRPC 中使用 stream RPC 紀錄到在 gRPC 中使用 stream RPC 的操作語法，但實際應用在專案上時卻卡關，主因是單元測試出現錯誤，</description></item><item><title>C# 搭配 gRPC 中使用 stream RPC</title><link>https://blog.yowko.com/csharp-grpc-stream/</link><pubDate>Sun, 16 Jun 2019 21:30:00 +0800</pubDate><guid>https://blog.yowko.com/csharp-grpc-stream/</guid><description>C# 搭配 gRPC 中使用 stream RPC gRPC 允許使用四種則型的 service 方法： 簡單 RPC (simple RPC) 主機端串流 RPC (server-side streaming RPC) 用戶端串流 RPC (client-side streaming RPC) 雙向串流 RPC (bidirectional streaming RPC) 過去的筆記都是使用 簡單 RPC (simple RPC</description></item></channel></rss>