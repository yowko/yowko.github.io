<!doctype html><html lang=zh-tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>使用 PerfTest 進行 RabbitMQ 效能測試 - Yowko&#39;s Notes</title><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content="Yowko Tsai"><meta name=description content="使用 PerfTest 進行 RabbitMQ 效能測試 之前筆記 在 CentOS7 上建立 RabbitMQ Cluster 提到打算透過針對 RabbitMQ 的效能測試來確認使用的硬體規格，今天就來紀錄該怎麼 使用 PerfTest 進行 RabbitMQ 效能測試 為了專注於"><meta name=keywords content=yowko,.net,blog><meta name=generator content="Hugo 0.56.3"><meta name=msvalidate.01 content=FA1ADBDB8F0BBBD0F7F4E65CDEBF7898><link rel=canonical href=https://blog.yowko.com/rabbitmq-perftest/><link rel=apple-touch-icon sizes=180x180 href=https://blog.yowko.com/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://blog.yowko.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://blog.yowko.com/favicon-16x16.png><link rel=manifest href=https://blog.yowko.com/manifest.json><link rel=mask-icon href=https://blog.yowko.com/safari-pinned-tab.svg color=#5bbad5><link href="https://blog.yowko.com/dist/even.min.css?v=3.2.0" rel=stylesheet><link href=https://blog.yowko.com/lib/fancybox/jquery.fancybox-3.1.20.min.css rel=stylesheet><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><meta property=og:title content="使用 PerfTest 進行 RabbitMQ 效能測試"><meta property=og:description content="使用 PerfTest 進行 RabbitMQ 效能測試 之前筆記 在 CentOS7 上建立 RabbitMQ Cluster 提到打算透過針對 RabbitMQ 的效能測試來確認使用的硬體規格，今天就來紀錄該怎麼 使用 PerfTest 進行 RabbitMQ 效能測試 為了專注於"><meta property=og:type content=article><meta property=og:url content=https://blog.yowko.com/rabbitmq-perftest/><meta property=article:published_time content=2021-08-03T21:30:00+08:00><meta property=article:modified_time content=2021-08-03T21:30:00+08:00><meta itemprop=name content="使用 PerfTest 進行 RabbitMQ 效能測試"><meta itemprop=description content="使用 PerfTest 進行 RabbitMQ 效能測試 之前筆記 在 CentOS7 上建立 RabbitMQ Cluster 提到打算透過針對 RabbitMQ 的效能測試來確認使用的硬體規格，今天就來紀錄該怎麼 使用 PerfTest 進行 RabbitMQ 效能測試 為了專注於"><meta itemprop=datePublished content=2021-08-03T21:30:00&#43;08:00><meta itemprop=dateModified content=2021-08-03T21:30:00&#43;08:00><meta itemprop=wordCount content=1737><meta itemprop=keywords content=RabbitMQ,benchmark,><meta name=twitter:card content=summary><meta name=twitter:title content="使用 PerfTest 進行 RabbitMQ 效能測試"><meta name=twitter:description content="使用 PerfTest 進行 RabbitMQ 效能測試 之前筆記 在 CentOS7 上建立 RabbitMQ Cluster 提到打算透過針對 RabbitMQ 的效能測試來確認使用的硬體規格，今天就來紀錄該怎麼 使用 PerfTest 進行 RabbitMQ 效能測試 為了專注於"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><link href=https://blog.yowko.com/opensearch.xml rel=search title="Content search" type=application/opensearchdescription+xml></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=https://blog.yowko.com/ class=logo>Yowko&#39;s Notes</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=https://blog.yowko.com/><li class=mobile-menu-item>首頁</li></a><a href=https://blog.yowko.com/post/><li class=mobile-menu-item>歷史筆記</li></a><a href=https://blog.yowko.com/tags/><li class=mobile-menu-item>內容標籤</li></a><a href=https://blog.yowko.com/search><li class=mobile-menu-item>站內搜尋</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header style=height:118px;padding-bottom:0><div class=logo-wrapper><a href=https://blog.yowko.com/ class=logo>Yowko&#39;s Notes</a></div><div style=padding-bottom:60px></div></nav><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/>首頁</a></li><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/post/>歷史筆記</a></li><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/tags/>內容標籤</a></li><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/search>站內搜尋</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><hr style="border-top:1px solid #e6e6e6;border-bottom:0;padding:0"><div id=content class=content><article class=post><header class=post-header><div class=post-meta><span class=post-time>2021-08-03</span>
<span class=more-meta>約 1737 字</span>
<span class=more-meta>預計閱讀 4 分鐘</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目錄</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#使用-perftest-進行-rabbitmq-效能測試>使用 PerfTest 進行 RabbitMQ 效能測試</a></li><li><a href=#基本環境說明>基本環境說明</a></li><li><a href=#使用方式>使用方式</a></li><li><a href=#心得>心得</a></li><li><a href=#參考資訊>參考資訊</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=使用-perftest-進行-rabbitmq-效能測試>使用 PerfTest 進行 RabbitMQ 效能測試</h2><p>之前筆記 <a href=https://blog.yowko.com/rabbitmq-cluster-centos7>在 CentOS7 上建立 RabbitMQ Cluster</a>
提到打算透過針對 RabbitMQ 的效能測試來確認使用的硬體規格，今天就來紀錄該怎麼 使用 PerfTest 進行 RabbitMQ 效能測試</p><p>為了專注於 PerfTest 使用紀錄，所以 RabbitMQ 的部份就透過 docker image 來快速建立，這樣一來可以想見效能比不上實體服務，如果想較忠實呈現效能數據建議依實際格規來建立 RabbitMQ 環境再做測試</p><h2 id=基本環境說明>基本環境說明</h2><ol><li>macOS Big Sur 11.5.1</li><li>.NET Core SDK 5.0.202</li><li>docker desktop 3.3.0(26916)</li><li><p>docker images</p><ul><li>rabbitmq:3.8</li><li>pivotalrabbitmq/perf-test:2.15.0</li></ul></li><li><p>測試用 RabbitMQ</p><blockquote><p>需要 RabbitMQ cluster，可以參考之前筆記 <a href=https://blog.yowko.com/rabbitmq-cluster-centos7>在 CentOS7 上建立 RabbitMQ Cluster</a></p></blockquote><pre><code class=language-bash>docker run -d --rm --name rabbitmq -p 5672:5672 rabbitmq:3.8
</code></pre></li></ol><h2 id=使用方式>使用方式</h2><ol><li><p>安裝方式</p><ul><li><p>使用 binary</p><blockquote><p>可以直接從 <a href=https://github.com/rabbitmq/rabbitmq-perf-test/releases target=_blank>GitHub releases</a> 下載</p></blockquote></li><li><p>使用 docker</p><blockquote><p>可以從 <a href=https://hub.docker.com/r/pivotalrabbitmq/perf-test/ target=_blank>dockerhub</a> 下載 docker image</p></blockquote></li></ul></li><li><p>參數說明</p><blockquote><p>大多數參數都沒用過，也有不少是看完不知道用法的，但既然都看了順便紀錄一下，也許下次看到時會比較有想法</p></blockquote><table><thead><tr><th>參數</th><th>說明</th></tr></thead><tbody><tr><td>-?,&ndash;help</td><td>說明文件</td></tr><tr><td>-a,&ndash;autoack</td><td>自動傳送 ack</td></tr><tr><td>-A,&ndash;multi-ack-every <code>&lt;arg&gt;</code></td><td>指定訊息累積量再一次 ack</td></tr><tr><td>-ad,&ndash;auto-delete <code>&lt;arg&gt;</code></td><td>queue 是否要自動刪除 (預設值： <code>true</code>)</td></tr><tr><td>-b,&ndash;heartbeat <code>&lt;arg&gt;</code></td><td>heartbeat 間隔</td></tr><tr><td>-B,&ndash;body <code>&lt;arg&gt;</code></td><td>使用指定的內容做為訊息，用 <code>逗號</code> 分隔多個檔案</td></tr><tr><td>-bc,&ndash;body-count <code>&lt;arg&gt;</code></td><td>預先產生的訊息內容數量；與 <code>--json-body</code> 一起使用 (預設值： <code>100</code>)</td></tr><tr><td>-bfc,&ndash;body-field-count <code>&lt;arg&gt;</code></td><td>預先產生內容的欄位與數值；與 <code>--json-body</code> 一起使用 (預設值： <code>100</code>)</td></tr><tr><td>-c,&ndash;confirm <code>&lt;arg&gt;</code></td><td>未確認訊息的最大發布數量</td></tr><tr><td>-C,&ndash;pmessages <code>&lt;arg&gt;</code></td><td>producer 訊息數量</td></tr><tr><td>-ca,&ndash;consumer-args <code>&lt;arg&gt;</code></td><td>consumer 參數使用 key/values，用 <code>逗號</code> 分隔， e.g. x-priority=10</td></tr><tr><td>-cri,&ndash;connection-recovery-interval <code>&lt;arg&gt;</code></td><td>連線復原間隔秒數 (預設值：<code>5</code>)；支援在兩個設定值間隨機進行嘗試(e.g. 30-60)</td></tr><tr><td>-ct,&ndash;confirm-timeout <code>&lt;arg&gt;</code></td><td>未確認發行訊息的等待時間(以 <code>秒</code> 為單位)</td></tr><tr><td>-ctp,&ndash;consumers-thread-pools <code>&lt;arg&gt;</code></td><td>所有 conumer 用的 thread pools 數量 (預設值：每個 consumer 使用一個 thread pool)</td></tr><tr><td>-d,&ndash;id <code>&lt;arg&gt;</code></td><td>test ID</td></tr><tr><td>-D,&ndash;cmessages <code>&lt;arg&gt;</code></td><td>consumer 訊息數量</td></tr><tr><td>-dcr,&ndash;disable-connection-recovery</td><td>停用自動連線復原</td></tr><tr><td>-e,&ndash;exchange <code>&lt;arg&gt;</code></td><td>exchange 名稱</td></tr><tr><td>-E,&ndash;exclusive</td><td>排除 server-named queues</td></tr><tr><td>-env,&ndash;environment-variables</td><td>顯示使用的環境變數</td></tr><tr><td>-f,&ndash;flag <code>&lt;arg&gt;</code></td><td>訊息 flag(s)，允許使用 <code>persistent</code> 與 <code>mandatory</code>，可以使用多次來指定不同值</td></tr><tr><td>-h,&ndash;uri <code>&lt;arg&gt;</code></td><td>connection URI</td></tr><tr><td>-H,&ndash;uris <code>&lt;arg&gt;</code></td><td>connection URIs (<code>逗號</code> 分隔)</td></tr><tr><td>-hst,&ndash;heartbeat-sender-threads <code>&lt;arg&gt;</code></td><td>producers and consumers heartbeat 用的 threads 數量</td></tr><tr><td>-i,&ndash;interval <code>&lt;arg&gt;</code></td><td>取樣間隔 (以 <code>秒</code> 為單位)</td></tr><tr><td>-jb,&ndash;json-body</td><td>產生隨機的 JSON 做為訊息內容.與 <code>--size</code> 一併使用</td></tr><tr><td>-k,&ndash;routing-key <code>&lt;arg&gt;</code></td><td>routing key</td></tr><tr><td>-K,&ndash;random-routing-key</td><td>每則訊息都使用隨機的 routing key</td></tr><tr><td>-l,&ndash;legacy-metrics</td><td>顯示傳統 metrics(min/avg/max latency)</td></tr><tr><td>-L,&ndash;consumer-latency <code>&lt;arg&gt;</code></td><td>consumer latency (以 <code>毫秒</code> 為單位)</td></tr><tr><td>-m,&ndash;ptxsize <code>&lt;arg&gt;</code></td><td>producer tx 大小</td></tr><tr><td>-M,&ndash;framemax <code>&lt;arg&gt;</code></td><td>frame max</td></tr><tr><td>-mh,&ndash;metrics-help</td><td>顯示 metrics 用量</td></tr><tr><td>-mp,&ndash;message-properties <code>&lt;arg&gt;</code></td><td>key/value 表示的訊息屬性，以 <code>逗號</code> 分隔，e.g. priority=5</td></tr><tr><td>-ms,&ndash;use-millis</td><td>latency 是否被蒐集(以 <code>毫秒</code> 為單位)，預設值：<code>false</code>.一般是 consumer 與 producer 在不同 server 上才啟用</td></tr><tr><td>-n,&ndash;ctxsize <code>&lt;arg&gt;</code></td><td>consumer tx 大小</td></tr><tr><td>-na,&ndash;nack</td><td>nack 並且 requeue 訊息</td></tr><tr><td>-niot,&ndash;nio-threads <code>&lt;arg&gt;</code></td><td>NIO threads 數量</td></tr><tr><td>-niotp,&ndash;nio-thread-pool <code>&lt;arg&gt;</code></td><td>NIO thread pool 數量，應該大於 NIO threads 數量</td></tr><tr><td>-o,&ndash;output-file <code>&lt;arg&gt;</code></td><td>將衡量結果寫至指定檔案</td></tr><tr><td>-p,&ndash;predeclared</td><td>允許使用預先定義的物件</td></tr><tr><td>-P,&ndash;publishing-interval <code>&lt;arg&gt;</code></td><td>以秒為單位的發布間隔（與生產者速率限制相反)</td></tr><tr><td>-pi,&ndash;polling-interval <code>&lt;arg&gt;</code></td><td>使用 basic.get 輪詢前等待的時間，以毫秒為單位，預設值： <code>0</code></td></tr><tr><td>-po,&ndash;polling</td><td>使用 basic.get 消費消息，不要在實際應用程式中使用</td></tr><tr><td>-prsd,&ndash;producer-random-start-delay <code>&lt;arg&gt;</code></td><td>以秒為單位的最大隨機延遲啟動 producers</td></tr><tr><td>-pst,&ndash;producer-scheduler-threads <code>&lt;arg&gt;</code></td><td>在使用 <code>--publishing-interval</code> 指定 threads 數量</td></tr><tr><td>-q,&ndash;qos <code>&lt;arg&gt;</code></td><td>consumer prefetch 數量</td></tr><tr><td>-Q,&ndash;global-qos <code>&lt;arg&gt;</code></td><td>channel prefetch 數量</td></tr><tr><td>-qa,&ndash;queue-args <code>&lt;arg&gt;</code></td><td>以 key/value 表示的, 以 <code>逗號</code> 分隔，e.g. x-max-length=10</td></tr><tr><td>-qf,&ndash;queue-file <code>&lt;arg&gt;</code></td><td>用來指定 queue name 的檔案</td></tr><tr><td>-qp,&ndash;queue-pattern <code>&lt;arg&gt;</code></td><td>用於建立 queue 的 queue name pattern 順序</td></tr><tr><td>-qpf,&ndash;queue-pattern-from <code>&lt;arg&gt;</code></td><td>queue name pattern 範圍開始 (包含)</td></tr><tr><td>-qpt,&ndash;queue-pattern-to <code>&lt;arg&gt;</code></td><td>queue name pattern 範圍結束 (包含)</td></tr><tr><td>-qq,&ndash;quorum-queue</td><td>建立 quorum queue(s)</td></tr><tr><td>-r,&ndash;rate <code>&lt;arg&gt;</code></td><td>producer rate 上限</td></tr><tr><td>-R,&ndash;consumer-rate <code>&lt;arg&gt;</code></td><td>consumer rate 上限</td></tr><tr><td>-rkcs,&ndash;routing-key-cache-size <code>&lt;arg&gt;</code></td><td>隨機 routing keys cache 的大小，看 <code>--random-routing-key</code></td></tr><tr><td>-S,&ndash;slow-start</td><td>延遲啟動 consumer (每個 consumer 延遲一秒)</td></tr><tr><td>-s,&ndash;size <code>&lt;arg&gt;</code></td><td>以 bytes 為單位的訊息大小</td></tr><tr><td>-sb,&ndash;skip-binding-queues</td><td>不要 bind queue 到 exchange</td></tr><tr><td>-se,&ndash;sasl-external</td><td>使用 SASL 外部身份驗證，預設值：<code>false</code>。如果使用帶有 rabbitmq_auth_mechanism_ssl 套件的客戶端證書身份驗證，則設置為 true。</td></tr><tr><td>-sni,&ndash;server-name-indication <code>&lt;arg&gt;</code></td><td>標記 TLS 參數的 server name ，以逗號分隔</td></tr><tr><td>-sst,&ndash;servers-startup-timeout <code>&lt;arg&gt;</code></td><td>以秒為單位的啟動超時（以防服務器在運行開始時不可用）。如果服務器不可用，默認是立即失敗。</td></tr><tr><td>-st,&ndash;shutdown-timeout <code>&lt;arg&gt;</code></td><td>終止的 timeout，預設值：<code>5</code> 秒</td></tr><tr><td>-sul,&ndash;servers-up-limit <code>&lt;arg&gt;</code></td><td>開始執行之前所需的可用服務器數。與 <code>--servers-start-timeout</code> 結合使用。預設值是從 <code>--uri</code> 或 <code>--uris</code> 推導出來的。</td></tr><tr><td>-t,&ndash;type <code>&lt;arg&gt;</code></td><td>exchange 類型</td></tr><tr><td>-T,&ndash;body-content-type <code>&lt;arg&gt;</code></td><td>內容 content-type</td></tr><tr><td>-u,&ndash;queue <code>&lt;arg&gt;</code></td><td>queue name</td></tr><tr><td>-udsc,&ndash;use-default-ssl-context</td><td>使用 JVM 預設 SSL context</td></tr><tr><td>-v,&ndash;version</td><td>顯示版本資訊</td></tr><tr><td>-vl,&ndash;variable-latency <code>&lt;arg&gt;</code></td><td>使用 [MICROSECONDS]:[DURATION] 語法的可變消費者處理延遲，其中 [MICROSECONDS] 整數 &gt;= 0 和 [DURATION] 整數 &gt; 0。多次使用該選項以指定多個值。</td></tr><tr><td>-vr,&ndash;variable-rate <code>&lt;arg&gt;</code></td><td>使用 [RATE]:[DURATION] 語法的可變發布速率，其中 [RATE] 整數 &gt;= 0 和 [DURATION] 整數 &gt; 0。多次使用該選項以指定多個值。</td></tr><tr><td>-vs,&ndash;variable-size <code>&lt;arg&gt;</code></td><td>使用 [SIZE]:[DURATION] 語法的可變消息大小，其中 [SIZE] 整數 &gt; 0 和 [DURATION] 整數 &gt; 0。多次使用該選項以指定多個值。</td></tr><tr><td>-x,&ndash;producers <code>&lt;arg&gt;</code></td><td>producer 數量</td></tr><tr><td>-X,&ndash;producer-channel-count <code>&lt;arg&gt;</code></td><td>每個 producer 的 channels 數量</td></tr><tr><td>-y,&ndash;consumers <code>&lt;arg&gt;</code></td><td>consumer 數量</td></tr><tr><td>-Y,&ndash;consumer-channel-count <code>&lt;arg&gt;</code></td><td>每個 consumer 的 channels 數量</td></tr><tr><td>-z,&ndash;time <code>&lt;arg&gt;</code></td><td>測試執行時間 (預設值： <code>永久執行</code>)</td></tr></tbody></table></li><li><p>執行測試</p><pre><code class=language-bash>docker run -it --rm pivotalrabbitmq/perf-test:latest -x 2 -y 4 -u &quot;throughput-test-1&quot; -a --id &quot;test 1&quot; -s 1000 -f persistent --uri amqp://192.168.80.3:5672 -z 30
</code></pre><blockquote><ul><li><code>-x</code> : 2 producer</li><li><code>-y</code> : 4 consumer</li><li><code>-u</code> : queue name 為 <code>throughput-test-1</code></li><li><code>-a</code> ： 自動 ack</li><li><code>--id</code> ： 測試 id 為 <code>test 1</code></li><li><code>-s</code> ： 將 message 大小設為 1000 bytes</li><li><code>-f</code> ： 使用 <code>persistent</code></li><li><code>--uri</code> ： RabbitMQ 位置為 <code>amqp://192.168.80.3:5672</code></li><li><code>-z</code> ：執行 30 秒</li></ul></blockquote></li><li><p>實際結果</p><p><img src=https://user-images.githubusercontent.com/3851540/127993345-2f8a5f79-cc42-475b-89b6-ea64877a9d06.png alt=1result></p></li></ol><h2 id=心得>心得</h2><p>看了幾份文件一直沒有找到比較明確的硬體規格需求計算方式，雖然使用 PerfTest 也沒有辦法回推目標用量所需的規格，但至少有個衡量的基準</p><p>工具本身參數很多，不敢說是多餘的，只能說目前所在團隊還沒有這些需求，但不免還是造成雜訊，看參數看半天結果用到的沒幾個XD</p><h2 id=參考資訊>參考資訊</h2><ol><li><a href=https://rabbitmq.github.io/rabbitmq-perf-test/stable/htmlsingle/ target=_blank>RabbitMQ PerfTest</a></li><li><a href=https://github.com/rabbitmq/rabbitmq-perf-test target=_blank>rabbitmq/rabbitmq-perf-test</a></li><li><a href=https://blog.csdn.net/zhuangzi123456/article/details/83858650 target=_blank>rabbitmq性能测试工具rabbitmq-perf-test（官网阅读笔记）</a></li><li><a href=https://blog.yowko.com/rabbitmq-cluster-centos7>在 CentOS7 上建立 RabbitMQ Cluster</a></li></ol></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Yowko Tsai</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-08-03</span></p><p class=copyright-item><span class=item-title>授權合約</span>
<span class=item-content>本部落格 (<a href=//blog.yowko.com target=_blank>Yowko&#39;s Notes</a>) 所有的文章內容(包含圖片)，任何轉載行為，必須通知並獲本部落格作者 (<a href=mailto:yowko@yowko.com>Yowko Tsai</a>) 的同意始得轉載,且轉載皆須註明出處與作者。<br><br><div class=separator style=clear:both;text-align:center><a href=//i.creativecommons.org/l/by-nc-sa/3.0/tw/88x31.png imageanchor=1 style=margin-left:1em;margin-right:1em><img border=0 src=//i.creativecommons.org/l/by-nc-sa/3.0/tw/88x31.png></a></div><br>&nbsp;<a href=//blog.yowko.com target=_blank>Yowko&#39;s Notes</a> 由 <a href=https://www.facebook.com/yowko.tsai target=_blank>Yowko Tsai</a> 製作，以<a href=//creativecommons.org/licenses/by-nc-sa/3.0/tw/ target=_blank>創用CC 姓名標示-非商業性-相同方式分享 3.0 台灣 授權條款</a>&nbsp;釋出。</span></p></div><footer class=post-footer><div class=post-tags>標籤：
<a href=https://blog.yowko.com/tags/rabbitmq/>RabbitMQ</a>
<a href=https://blog.yowko.com/tags/benchmark/>benchmark</a></div><nav class=post-nav><div><a class=prev href=https://blog.yowko.com/rabbitmqadmin-not-found/ style=float:none><span class="next-text nav-mobile" style=display:inline-block>下一篇</span>
<i class="fas fa-arrow-circle-right"></i><span class="next-text nav-default">找不到 rabbitmqadmin ？！</span></a></div><div><a class=prev href=https://blog.yowko.com/rabbitmq-cluster-centos7/ style=float:none><span class="prev-text nav-mobile" style=display:inline-block>上一篇</span>
<i class="fas fa-arrow-circle-left"></i><span class="prev-text nav-default">在 CentOS7 上建立 RabbitMQ Cluster</span></a></div></nav></footer></article></div><div id=disqus_thread></div><script type=text/javascript>var disqus_config=function(){this.page.url='https:\/\/blog.yowko.com\/rabbitmq-perftest\/';};(function(){if(window.location.hostname==='localhost')return;var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;var disqus_shortname='yowkonotes';dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:yowko@yowko.com class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/yowko/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/yowko class="iconfont icon-github" title=github></a><a href=https://blog.yowko.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 強力驅動</span>
<span class=division>|</span>
<span class=theme-info>主題 -
<a class=theme-link href=https://github.com/huanlin/hugo-theme-even-more>Even More</a></span>
<span class=copyright-year>&copy;
2016 -
2022
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Yowko Tsai</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="https://blog.yowko.com/lib/highlight/highlight.pack.js?v=20171001"></script><script type=text/javascript src=https://blog.yowko.com/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=https://blog.yowko.com/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=https://blog.yowko.com/lib/fancybox/jquery.fancybox-3.1.20.min.js></script><script type=text/javascript src=https://blog.yowko.com/lib/instantclick/instantclick-3.0.1.min.js data-no-instant></script><script data-no-instant>InstantClick.init();</script><script type=text/javascript src="https://blog.yowko.com/dist/even.min.js?v=3.2.0"></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-88810280-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>