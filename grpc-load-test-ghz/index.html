<!doctype html><html lang=zh-tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>使用 ghz 來對 gRPC 做負載測試 - Yowko&#39;s Notes</title><meta name=google-site-verification content=DvajWUA2XrtSgjsnGxXQKihwijBDiTFw9g7cxFY-Ivk><meta name=renderer content=webkit><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta name=theme-color content=#f8f5ec><meta name=msapplication-navbutton-color content=#f8f5ec><meta name=apple-mobile-web-app-capable content=yes><meta name=apple-mobile-web-app-status-bar-style content=#f8f5ec><meta name=author content="Yowko Tsai"><meta name=description content="使用 ghz 來對 gRPC 做負載測試 最近興起想要比較幾個 gRPC load test 工具的使用心得，這才發現過去在建立 gRPC service 時因為專案時間壓力並沒有特別紀錄 ghz 的用法，後來工作也慢"><meta name=keywords content=yowko,.net,blog><meta name=generator content="Hugo 0.56.3"><meta name=msvalidate.01 content=FA1ADBDB8F0BBBD0F7F4E65CDEBF7898><link rel=canonical href=https://blog.yowko.com/grpc-load-test-ghz/><link rel=apple-touch-icon sizes=180x180 href=https://blog.yowko.com/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://blog.yowko.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://blog.yowko.com/favicon-16x16.png><link rel=manifest href=https://blog.yowko.com/manifest.json><link rel=mask-icon href=https://blog.yowko.com/safari-pinned-tab.svg color=#5bbad5><link href="https://blog.yowko.com/dist/even.min.css?v=3.2.0" rel=stylesheet><link href=https://blog.yowko.com/lib/fancybox/jquery.fancybox-3.1.20.min.css rel=stylesheet><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.2.0/css/all.css integrity=sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ crossorigin=anonymous><meta property=og:title content="使用 ghz 來對 gRPC 做負載測試"><meta property=og:description content="使用 ghz 來對 gRPC 做負載測試 最近興起想要比較幾個 gRPC load test 工具的使用心得，這才發現過去在建立 gRPC service 時因為專案時間壓力並沒有特別紀錄 ghz 的用法，後來工作也慢"><meta property=og:type content=article><meta property=og:url content=https://blog.yowko.com/grpc-load-test-ghz/><meta property=article:published_time content=2022-04-04T00:30:00+08:00><meta property=article:modified_time content=2022-04-04T00:30:31+08:00><meta itemprop=name content="使用 ghz 來對 gRPC 做負載測試"><meta itemprop=description content="使用 ghz 來對 gRPC 做負載測試 最近興起想要比較幾個 gRPC load test 工具的使用心得，這才發現過去在建立 gRPC service 時因為專案時間壓力並沒有特別紀錄 ghz 的用法，後來工作也慢"><meta itemprop=datePublished content=2022-04-04T00:30:00&#43;08:00><meta itemprop=dateModified content=2022-04-04T00:30:31&#43;08:00><meta itemprop=wordCount content=2570><meta itemprop=keywords content="ASP.NET Core,csharp,gRPC,Benchmark,"><meta name=twitter:card content=summary><meta name=twitter:title content="使用 ghz 來對 gRPC 做負載測試"><meta name=twitter:description content="使用 ghz 來對 gRPC 做負載測試 最近興起想要比較幾個 gRPC load test 工具的使用心得，這才發現過去在建立 gRPC service 時因為專案時間壓力並沒有特別紀錄 ghz 的用法，後來工作也慢"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><link href=https://blog.yowko.com/opensearch.xml rel=search title="Content search" type=application/opensearchdescription+xml></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=https://blog.yowko.com/ class=logo>Yowko&#39;s Notes</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=https://blog.yowko.com/><li class=mobile-menu-item>首頁</li></a><a href=https://blog.yowko.com/post/><li class=mobile-menu-item>歷史筆記</li></a><a href=https://blog.yowko.com/tags/><li class=mobile-menu-item>內容標籤</li></a><a href=https://blog.yowko.com/search><li class=mobile-menu-item>站內搜尋</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header style=height:118px;padding-bottom:0><div class=logo-wrapper><a href=https://blog.yowko.com/ class=logo>Yowko&#39;s Notes</a></div><div style=padding-bottom:60px></div></nav><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/>首頁</a></li><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/post/>歷史筆記</a></li><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/tags/>內容標籤</a></li><li class=menu-item><a class=menu-item-link href=https://blog.yowko.com/search>站內搜尋</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><hr style="border-top:1px solid #e6e6e6;border-bottom:0;padding:0"><div id=content class=content><article class=post><header class=post-header><div class=post-meta><span class=post-time>2022-04-04</span>
<span class=more-meta>約 2570 字</span>
<span class=more-meta>預計閱讀 6 分鐘</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目錄</h2><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#使用-ghz-來對-grpc-做負載測試>使用 ghz 來對 gRPC 做負載測試</a></li><li><a href=#基本環境說明>基本環境說明</a></li><li><a href=#下載與安裝>下載與安裝</a></li><li><a href=#使用方式>使用方式</a></li><li><a href=#實際使用方式>實際使用方式</a></li><li><a href=#心得>心得</a></li><li><a href=#參考資訊>參考資訊</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=使用-ghz-來對-grpc-做負載測試>使用 ghz 來對 gRPC 做負載測試</h2><p>最近興起想要比較幾個 gRPC load test 工具的使用心得，這才發現過去在建立 gRPC service 時因為專案時間壓力並沒有特別紀錄 ghz 的用法，後來工作也慢慢以 DevOps 為主，剛好趁這個機會順便複習一下</p><p>ghz 是一套用 <code>go</code> 撰寫的 command line 工具，主要是用於進行 load test 與 benchmark gRPC 服務</p><h2 id=基本環境說明>基本環境說明</h2><ol><li>macOS Monterey 12.3.1</li><li>ghz v0.106.1</li><li><p>ASP.NET Core gRPC server default project template</p><ul><li><p>greet.proto</p><pre><code class=language-proto>syntax = &quot;proto3&quot;;
option csharp_namespace = &quot;grpc6&quot;;
        
package greet;
        
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply);
}
        
// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}
        
// The response message containing the greetings.
message HelloReply {
  string message = 1;
}
        
</code></pre></li></ul></li><li><p>streaming 部份參考之前筆記 <a href=https://blog.yowko.com/csharp-grpc-stream/>C# 搭配 gRPC 中使用 stream RPC</a></p><ul><li><p>greet.proto</p><pre><code class=language-proto>service CandidateService {
  rpc DownloadCv (DownloadByName) returns (stream Candidate);
  rpc CreateCv (stream Candidate) returns (CreateCvResponse);
  rpc CreateDownloadCv (stream Candidate) returns (stream Candidates);
}
        
message Candidates {
    repeated Candidate Candidates = 2;
}
message Candidate {
    string Name = 1;
    repeated Job Jobs = 2;
}
message Job {
    string Title = 1;
    int32 Salary = 2;
    string JobDescription = 3;
}
message DownloadByName {
    string Name = 1;
}
message CreateCvResponse {
    bool IsSuccess = 1;
}
</code></pre></li><li><p>CandidateService</p><pre><code class=language-cs>public class CandidateService:grpc6.CandidateService.CandidateServiceBase
{
    public override async Task&lt;CreateCvResponse&gt; CreateCv(IAsyncStreamReader&lt;Candidate&gt; requestStream, ServerCallContext context)
    {
        var result = new CreateCvResponse
        {
            IsSuccess = false
        };
        // stream 讀取
        while (await requestStream.MoveNext())
        {
            var candidate = requestStream.Current;
            // 實際處理
            Console.WriteLine(candidate.Name);
        }
        return result;
    }
        
        
    public override async Task DownloadCv(DownloadByName request, IServerStreamWriter&lt;Candidate&gt; responseStream, ServerCallContext context)
    {
        var fakeJobs = new Faker&lt;Job&gt;()
            .RuleFor(a =&gt; a.Title, (f, u) =&gt; f.Company.Bs())
            .RuleFor(a =&gt; a.Salary, (f, u) =&gt; f.Commerce.Random.Int(1000, 2000))
            .RuleFor(a =&gt; a.JobDescription, (f, u) =&gt; f.Lorem.Text());
        var createRequests = new Faker&lt;Candidate&gt;()
            .RuleFor(a =&gt; a.Name, (f, u) =&gt; f.Name.FullName())
            .RuleFor(a =&gt; a.Jobs, (f, u) =&gt;
            {
                u.Jobs.AddRange(fakeJobs.GenerateBetween(3, 5));
                return u.Jobs;
            }).Generate();
        // 將每筆資料逐一透過 WriteAsync 輸出
        await responseStream.WriteAsync(createRequests);
    }
        
    public override async Task CreateDownloadCv(IAsyncStreamReader&lt;Candidate&gt; requestStream, IServerStreamWriter&lt;Candidates&gt; responseStream, ServerCallContext context)
    {
        var candidates = new Candidates();
        // 將收到的資料逐一取出
        while (await requestStream.MoveNext())
        {
            var candidate = requestStream.Current;
            candidates.Candidates_.Add(candidate);
            // 將處理後的資料回傳
            await responseStream.WriteAsync(candidates);
        }
    }
}
</code></pre></li></ul></li></ol><h2 id=下載與安裝>下載與安裝</h2><blockquote><p>擇一即可</p></blockquote><ol><li><p>下載</p><p>可以至 <a href=https://github.com/bojand/ghz/releases target=_blank>ghz:GitHub releases page</a> 下載所需環境 os 的壓縮檔後解壓縮使用</p></li><li><p>mac 可以使用 hoembrew 安裝</p><pre><code class=language-bash>brew install ghz
</code></pre></li></ol><h2 id=使用方式>使用方式</h2><ol><li><p>語法</p><pre><code class=language-BASH>ghz [&lt;flags&gt;] [&lt;host&gt;]
</code></pre></li><li><p>範例</p><pre><code class=language-bash>ghz --insecure --proto ./grpc6/Protos/greet.proto --call greet.Greeter.SayHello -d '{&quot;name&quot;:&quot;Yowko&quot;}' 0.0.0.0:5143
</code></pre></li><li><p><code>&lt;flags&gt;</code> 參數說明</p><ul><li><p><code>--config</code></p><blockquote><ul><li>指定 <code>JSON</code> 或是 <code>TOML</code> 格式的檔案位置</li><li>config 檔案的設定值會與 cli 參數整併且 cli 參數優先權較高 (cli 參數會覆寫 config 檔案設定值)</li></ul></blockquote></li><li><p><code>--proto</code></p><blockquote><ul><li>指定定義 service 的 <code>.proto</code> 檔案位置</li><li>若未指定 <code>--proto</code> 與 <code>--protoset</code> 則會嘗試透過 server reflection 來取得可用 service</li></ul></blockquote></li><li><p><code>--protoset</code></p><blockquote><ul><li>指定編譯過的 <code>.protoset</code> 檔案位置</li><li>若未指定 <code>--proto</code> 與 <code>--protoset</code> 則會嘗試透過 server reflection 來取得可用 service</li></ul></blockquote></li><li><p><code>--call</code> ?</p><blockquote><ul><li>呼叫完全符合規則的方法：格式為 <code>package.Service/Method</code> or <code>package.Service.Method</code></li></ul></blockquote></li><li><p><code>-i</code>, <code>--import-paths</code></p><blockquote><ul><li>用來指定 import proto 的路徑</li><li>可以使用 <code>,</code> 來指定多組路徑</li><li>目前所在資料夾與使用 <code>--proto</code> 指定的 proto 檔所在資料夾都會自動加入 import 清單中</li></ul></blockquote></li><li><p><code>--cacert</code></p><blockquote><ul><li>指定可用來驗證 server 的可信任根憑證位置</li><li>ghz 預設會使用系統的預設根憑證來建立安全連線</li><li>加上 <code>--skipTLS</code> 可以略過 TLS 檢查</li></ul></blockquote></li><li><p><code>--cert</code></p><blockquote><ul><li>指定 client 憑證 (公鑰) 的位置</li><li>必需同時使用 <code>--key</code></li></ul></blockquote></li><li><p><code>--key</code></p><blockquote><ul><li>指定 client 私鑰的位置</li><li>必需同時使用 <code>--cert</code></li></ul></blockquote></li><li><p><code>--cname</code></p><blockquote><ul><li>驗證 TLS 憑證時覆寫 server 名稱</li></ul></blockquote></li><li><p><code>--skipTLS</code></p><blockquote><ul><li>略過 server 憑證鏈與主機名稱的 TLS client 驗證</li></ul></blockquote></li><li><p><code>--insecure</code></p><blockquote><ul><li>使用明碼與不安全連線</li></ul></blockquote></li><li><p><code>--authority</code></p><blockquote><ul><li>會將值做為 <code>:authority</code> pseudo-header</li><li>只在使用 <code>--insecure</code> 有用</li></ul></blockquote></li><li><p><code>--async</code></p><blockquote><ul><li>儘快使 request 做非同步</li></ul></blockquote></li><li><p><code>-r</code>, <code>--rps</code></p><blockquote><ul><li>所有 RPS (requests per second) 的速率限制</li><li>預設值為 <code>0</code> (無限制)</li><li>所有 RPS 會依照指定的 concurrency 選項分送給 worker</li></ul></blockquote></li><li><p><code>--load-schedule</code></p><blockquote><ul><li>指定 load test 排程模式</li><li>允許設定值：<code>const</code>、<code>step</code> 與 <code>line</code></li><li>預設值為：<code>const</code></li><li>使用 <code>const</code> 時以 <code>q</code> 選項來指定 RPS (我看說明文件沒有關係 <code>q</code> option 的內容)</li><li>使用 <code>step</code> 時以 <code>load-start</code>, <code>load-step</code>, <code>load-end</code>, <code>load-step-duration</code>, 與 <code>load-max-duration</code> 來決定階段性增減的細節</li><li>使用 <code>line</code> 時以 <code>load-start</code>, <code>load-step</code>, <code>load-end</code>, <code>load-step-duration</code>, 與 <code>load-max-duration</code> 來線性增減，但 <code>line</code> 就是線性增減，原則上就是透過 <code>load-step</code> 指定斜率且 <code>load-step-duration</code> 就是 <code>1s</code></li></ul></blockquote></li><li><p><code>--load-start</code></p><blockquote><ul><li>指定 load test 開始的 RPS</li><li>適用於 <code>step</code> 或 <code>line</code> 模式</li></ul></blockquote></li><li><p><code>--load-step</code></p><blockquote><ul><li>在 <code>step</code> 模式下指定 load test 遞增的 RPS 值</li><li>在 <code>line</code> 模式下指定 load test 斜率</li></ul></blockquote></li><li><p><code>--load-end</code></p><blockquote><ul><li>指定 load test 終止的 RPS (可不提供)</li><li>適用於 <code>step</code> 或 <code>line</code> 模式</li><li><code>load-end</code> 與 <code>load-max-duration</code> 以先達成的優先</li></ul></blockquote></li><li><p><code>--load-max-duration</code></p><blockquote><ul><li>指定 load test 最長持續時間(可不提供)</li><li>以 <code>--load-end</code> 的 RPS 數量執行這個時間設定的 load test</li><li><code>load-end</code> 與 <code>load-max-duration</code> 以先達成的優先</li></ul></blockquote></li><li><p><code>-c</code>, <code>--concurrency</code></p><blockquote><ul><li>指定同時執行的 worker 數</li><li>適用於 <code>const</code> 並發排程模式</li></ul></blockquote></li><li><p><code>--concurrency-schedule</code></p><blockquote><ul><li>指定 load test 並發排程模式</li><li>允許設定值：<code>const</code>、<code>step</code> 與 <code>line</code></li><li>預設值為：<code>const</code></li></ul></blockquote></li><li><p><code>--concurrency-start</code></p><blockquote><ul><li>指定 load test 開始的並發 RPS</li><li>適用於 <code>step</code> 或 <code>line</code> 並發模式</li></ul></blockquote></li><li><p><code>--concurrency-end</code></p><blockquote><ul><li>指定 load test 終止的並發 RPS</li><li>適用於 <code>step</code> 或 <code>line</code> 並發模式</li></ul></blockquote></li><li><p><code>--concurrency-step=1</code></p><blockquote><ul><li>在 <code>step</code> 並發模式下指定 load test 遞增的 RPS 值</li><li>在 <code>line</code> 並發模式下指定 load test 斜率</li></ul></blockquote></li><li><p><code>--concurrency-step-duration</code></p><blockquote><ul><li>指定 load test 並發 step 持續時間</li><li>適用於 <code>step</code> 並發模式</li></ul></blockquote></li><li><p><code>--concurrency-max-duration</code></p><blockquote><ul><li>指定 load test 並發最長持續時間</li><li>適用於 <code>step</code> 或 <code>line</code> 並發模式</li></ul></blockquote></li><li><p><code>-n</code>, <code>--total</code></p><blockquote><ul><li>指定總測試的 request 數量</li><li>預設為 <code>200</code></li><li>benchmark 主要就是 <code>-n</code> 挑配 <code>-c</code> 取得的</li></ul></blockquote></li><li><p><code>-t</code>, <code>--timeout</code></p><blockquote><ul><li>指定每個 request timeout 的時間</li><li>預設為 <code>20s</code></li><li><code>0</code> 表示永不 timeout</li></ul></blockquote></li><li><p><code>-z</code>, <code>--duration</code></p><blockquote><ul><li>指定發出 request 的持續時間</li><li>如果設定這個值，<code>-n</code> 的設定就會被忽略</li></ul></blockquote></li><li><p><code>-x</code>, <code>--max-duration</code></p><blockquote><ul><li>不忽略 <code>-n</code> 設定的最長執行時間</li><li>如果在 <code>-n</code> (最大測試總量) 完成前，達成這個設求，程式依然會停止</li></ul></blockquote></li><li><p><code>--duration-stop</code></p><blockquote><ul><li>指定 <code>-z</code> (duration) 已滿足的情況下，如何處理已發送但仍未完成的 request</li><li>允許設定值：<code>close</code>、<code>wait</code> 與 <code>ignore</code></li><li><code>close</code>：立即關閉連線，可能會出現錯誤：<code>transport is closing</code></li><li><code>wait</code>：會等待 request 完成，但仍需遵守 <code>-t</code> 設定</li><li><code>ignore</code>：會立即關閉連線，但報告不會將這些 request 計入</li></ul></blockquote></li><li><p><code>-d</code>, <code>--data</code></p><blockquote><ul><li>以 stringified JSON 做為呼叫的資料</li><li>如果 value 中有 <code>@</code> 則以 <code>stdin</code> 讀取內容</li><li>一元請求(unary requests) 允許 <code>一個</code> (重複用) 或是 <code>陣列</code> (循環用) 訊息</li><li>client streaming or bi-directional streaming 則僅允許 json 陣列 (就算只提供一個 json 也會轉為只有一個元素的陣列)</li></ul></blockquote></li><li><p><code>-D</code>, <code>--data-file</code></p><blockquote><ul><li>提供呼叫資料的 json 路徑</li></ul></blockquote></li><li><p><code>-b</code>, <code>--binary</code></p><blockquote><ul><li>呼叫資料可以從 <code>stdin</code> 讀取並序列化為 protocol buffer 訊息</li></ul></blockquote></li><li><p><code>-B</code>, <code>--binary-file</code></p><blockquote><ul><li>指定序列化過的呼叫資料檔案路徑</li></ul></blockquote></li><li><p><code>-m</code>, <code>--metadata</code></p><blockquote><ul><li>stringified JSON 的 request metadat</li></ul></blockquote></li><li><p><code>-M</code>, <code>--metadata-file</code></p><blockquote><ul><li>metadata 的檔案路徑</li></ul></blockquote></li><li><p><code>--stream-interval</code></p><blockquote><ul><li>streaming 間隔時間</li><li>僅適用於 <code>client streaming</code> or <code>bi-directional streaming</code></li></ul></blockquote></li><li><p><code>--stream-call-duration</code></p><blockquote><ul><li>最大的 stream 呼叫持續時間</li><li><code>client streaming</code> or <code>bi-directional streaming</code> 會持續發送至時間到</li><li><code>server streaming</code> 會持續接受到時間到 (會出現 canceled error)</li></ul></blockquote></li><li><p><code>--stream-call-count</code></p><blockquote><ul><li>設定 streaming 最大的發送訊息數量 (<code>client streaming</code> or <code>bi-directional streaming</code>)或接收訊數量 (<code>server streaming</code>)</li><li>若 call data 大於指定數量，只會取部份使用；若資料小於指定數量則會重複使用</li></ul></blockquote></li><li><p><code>--stream-dynamic-messages</code></p><blockquote><ul><li>允許重態建立 streaming 訊息內容</li></ul></blockquote></li><li><p><code>--reflect-metadata</code></p><blockquote><ul><li>將 metadata 反射為 stringified JSON</li><li>僅用於 reflection 的 request</li></ul></blockquote></li><li><p><code>--max-recv-message-size</code></p><blockquote><ul><li>指定最大允許 client 接收的訊息大小</li><li>可以使用 <code>bytes</code> 設定，或是 <code>42 MB</code> 這類 <a href=https://pkg.go.dev/github.com/dustin/go-humanize#ParseBytes target=_blank>human readable value</a></li></ul></blockquote></li><li><p><code>--max-send-message-size</code></p><blockquote><ul><li>指定最大允許 client 傳送的訊息大小</li><li>可以使用 <code>bytes</code> 設定，或是 <code>42 MB</code> 這類 <a href=https://pkg.go.dev/github.com/dustin/go-humanize#ParseBytes target=_blank>human readable value</a></li></ul></blockquote></li><li><p><code>-o</code>, <code>--output</code></p><blockquote><ul><li>指定輸出的檔案位置</li><li>預設是 <code>none</code>，即透過 <code>stdout</code> 輸出</li></ul></blockquote></li><li><p><code>-O</code>, <code>--format</code></p><blockquote><ul><li>設定輸出格式，如果未設定只會顯示概要</li><li><code>csv</code> : 將指標以逗號分隔呈現</li><li><code>json</code> : 將指標以 json 格式呈現</li><li><code>pretty</code> : 將指標以利於閱讀的 json 格式呈現</li><li><code>html</code> : 將指標以 htlm 呈現</li><li><code>influx-summary</code> : 將指標概要以 InfluxDB line protocol 呈現</li><li><code>influx-details</code> : 將指標細節以 InfluxDB line protocol 呈現</li><li><code>prometheus</code> : 將指標概要以 Prometheus exposition 呈現.</li></ul></blockquote></li><li><p><code>--skipFirst</code></p><blockquote><ul><li>設定忽略頭幾個 response</li></ul></blockquote></li><li><p><code>--connections</code></p><blockquote><ul><li>設定 gRPC 連線數 (預設只有建立一條 gRPC 連線)</li><li>這個設定值不能大於 <code>-c</code> 數量</li><li>連線數會分圴分配給 worker 使用</li></ul></blockquote></li><li><p><code>--connect-timeout</code></p><blockquote><ul><li>設定初始化連線 timeout 時間</li><li>預設為 <code>20s</code></li></ul></blockquote></li><li><p><code>--keepalive</code></p><blockquote><ul><li>設定 keepalive 時間</li><li>只在明確設定且數值大於 <code>0</code> 會套用</li></ul></blockquote></li><li><p><code>--name</code></p><blockquote><ul><li>自訂 load test 名稱</li></ul></blockquote></li><li><p><code>--tags</code></p><blockquote><ul><li>自訂的 tag</li><li>以 <code>json</code> string 方式設定</li></ul></blockquote></li><li><p><code>--cpus</code></p><blockquote><ul><li>指定用於執行 load test 的 cpu 數量</li><li>預設是本機的所有邏輯 cpu 總數</li></ul></blockquote></li><li><p><code>--debug</code></p><blockquote><ul><li>指定 debug log file 的路徑</li><li>debug log 是 <code>json</code> 格式</li></ul></blockquote></li><li><p><code>-e</code>, <code>--enable-compression</code></p><blockquote><ul><li>在 request 上啟用 gzip 壓縮</li></ul></blockquote></li><li><p><code>--count-errors</code></p><blockquote><ul><li>啟用統計 error</li><li>預設 <code>最快</code>,<code>最慢</code>, <code>平均</code>, <code>直方圖</code>, <code>延遲分佈</code> 都只計算正確回應</li></ul></blockquote></li><li><p><code>-v</code>, <code>--version</code></p><blockquote><ul><li>顯示版本</li></ul></blockquote></li><li><p><code>-h</code>, <code>--help</code></p><blockquote><ul><li>顯示 help 文件</li><li>也可以使用 <code>--help-long</code> 與 <code>--help-man</code></li></ul></blockquote></li></ul></li></ol><h2 id=實際使用方式>實際使用方式</h2><ol><li><p>Unary call</p><pre><code class=language-bash>ghz -c 20 -n 20000 --insecure --proto ./grpc6/Protos/greet.proto --call greet.Greeter.SayHello -d '{&quot;name&quot;:&quot;Yowko&quot;}' 0.0.0.0:5143
</code></pre><p><img src=https://user-images.githubusercontent.com/3851540/161880801-a240df0f-6534-4711-8004-f56ce7b1d9be.png alt=1unarycall></p></li><li><p>client streaming</p><pre><code class=language-bash>ghz -c 20 -n 20000 --insecure --proto ./grpc6/Protos/greet.proto --call greet.CandidateService.CreateCv -d '[{ &quot;Name&quot;: &quot;Yowko&quot;, &quot;Jobs&quot;: [{&quot;Title&quot;: &quot;SRE&quot;,&quot;Salary&quot;: 10,&quot;JobDescription&quot;: &quot;DevOps&quot;},{&quot;Title&quot;: &quot;Programmer&quot;,&quot;Salary&quot;: 5,&quot;JobDescription&quot;: &quot;C#&quot;}] }, { &quot;Name&quot;: &quot;Test&quot;, &quot;Jobs&quot;: [{&quot;Title&quot;: &quot;SRE&quot;,&quot;Salary&quot;: 8,&quot;JobDescription&quot;: &quot;DevOps&quot;},{&quot;Title&quot;: &quot;Programmer&quot;,&quot;Salary&quot;: 7,&quot;JobDescription&quot;: &quot;golang&quot;}] }]' 0.0.0.0:5143
</code></pre><p><img src=https://user-images.githubusercontent.com/3851540/161880810-d32f1038-9723-4ed1-b201-b2c1d7cebd85.png alt=2clientstream></p></li><li><p>server streaming</p><pre><code class=language-bash>ghz -c 20 -n 20000 --insecure --proto ./grpc6/Protos/greet.proto --call greet.CandidateService.DownloadCv -d '{ &quot;Name&quot;: &quot;Yowko&quot; }' 0.0.0.0:5143
</code></pre><p><img src=https://user-images.githubusercontent.com/3851540/161880815-e8f2e545-58a5-4218-8dd0-fbb676684746.png alt=3serverstream></p></li><li><p>bi-directional streaming</p><pre><code class=language-bash>ghz -c 20 -n 20000 --insecure --proto ./grpc6/Protos/greet.proto --call greet.CandidateService.CreateDownloadCv -d '[{ &quot;Name&quot;: &quot;Yowko&quot;, &quot;Jobs&quot;: [{&quot;Title&quot;: &quot;SRE&quot;,&quot;Salary&quot;: 10,&quot;JobDescription&quot;: &quot;DevOps&quot;},{&quot;Title&quot;: &quot;Programmer&quot;,&quot;Salary&quot;: 5,&quot;JobDescription&quot;: &quot;C#&quot;}] }, { &quot;Name&quot;: &quot;Test&quot;, &quot;Jobs&quot;: [{&quot;Title&quot;: &quot;SRE&quot;,&quot;Salary&quot;: 8,&quot;JobDescription&quot;: &quot;DevOps&quot;},{&quot;Title&quot;: &quot;Programmer&quot;,&quot;Salary&quot;: 7,&quot;JobDescription&quot;: &quot;golang&quot;}] }]' 0.0.0.0:5143
</code></pre><p><img src=https://user-images.githubusercontent.com/3851540/161880816-a01334f4-259c-440f-879a-7d63e110cde9.png alt=4bidirection></p></li></ol><h2 id=心得>心得</h2><p>ghz 是我最早接觸的 gRPC load test 工具，一直以來都是用它來為 gRPC service 做基本的效能評估，以我的立場來看，優點是功能多可以滿足多數情境，缺點是功能多導致參數也多，官網的 sample 又偏向簡單，不少參數不好理解實際應用情境，另外 grpc service 的呼叫格式與其他工具(grpcurl、ghz)略有不同 (<code>{package name}.{service name}.{procedure name}</code> vs <code>{package name}.{service name}/{procedure name}</code>)</p><h2 id=參考資訊>參考資訊</h2><ol><li><a href=https://ghz.sh/ target=_blank>ghz:gRPC benchmarking and load testing tool</a></li><li><a href=https://github.com/bojand/ghz/releases target=_blank>ghz:GitHub releases page</a></li><li><a href=https://ghz.sh/docs/options target=_blank>ghz: Options Reference</a></li></ol></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>Yowko Tsai</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2022-04-04</span></p><p class=copyright-item><span class=item-title>授權合約</span>
<span class=item-content>本部落格 (<a href=//blog.yowko.com target=_blank>Yowko&#39;s Notes</a>) 所有的文章內容(包含圖片)，任何轉載行為，必須通知並獲本部落格作者 (<a href=mailto:yowko@yowko.com>Yowko Tsai</a>) 的同意始得轉載,且轉載皆須註明出處與作者。<br><br><div class=separator style=clear:both;text-align:center><a href=//i.creativecommons.org/l/by-nc-sa/3.0/tw/88x31.png imageanchor=1 style=margin-left:1em;margin-right:1em><img border=0 src=//i.creativecommons.org/l/by-nc-sa/3.0/tw/88x31.png></a></div><br>&nbsp;<a href=//blog.yowko.com target=_blank>Yowko&#39;s Notes</a> 由 <a href=https://www.facebook.com/yowko.tsai target=_blank>Yowko Tsai</a> 製作，以<a href=//creativecommons.org/licenses/by-nc-sa/3.0/tw/ target=_blank>創用CC 姓名標示-非商業性-相同方式分享 3.0 台灣 授權條款</a>&nbsp;釋出。</span></p></div><footer class=post-footer><div class=post-tags>標籤：
<a href=https://blog.yowko.com/tags/asp.net-core/>ASP.NET Core</a>
<a href=https://blog.yowko.com/tags/csharp/>C#</a>
<a href=https://blog.yowko.com/tags/grpc/>gRPC</a>
<a href=https://blog.yowko.com/tags/benchmark/>Benchmark</a></div><nav class=post-nav><div><a class=prev href=https://blog.yowko.com/grpc-load-test-k6/ style=float:none><span class="next-text nav-mobile" style=display:inline-block>下一篇</span>
<i class="fas fa-arrow-circle-right"></i><span class="next-text nav-default">使用 k6 來對 gRPC 做負載測試</span></a></div><div><a class=prev href=https://blog.yowko.com/aspdotnet-core-31-amd64-arm/ style=float:none><span class="prev-text nav-mobile" style=display:inline-block>上一篇</span>
<i class="fas fa-arrow-circle-left"></i><span class="prev-text nav-default">如何讓 ASP.NET Core 3.1 以 amd64 image 在 arm 晶片 (M1) 上執行</span></a></div></nav></footer></article></div><script src=https://giscus.app/client.js data-repo=yowko/yowko.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxODA1MTU2MTE=" data-category=Announcements data-category-id=DIC_kwDOCsJzG84CW4SD data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-TW crossorigin=anonymous async></script></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:yowko@yowko.com class="iconfont icon-email" title=email></a><a href=https://www.linkedin.com/in/yowko/ class="iconfont icon-linkedin" title=linkedin></a><a href=https://github.com/yowko class="iconfont icon-github" title=github></a><a href=https://blog.yowko.com/index.xml type=application/rss+xml class="iconfont icon-rss" title=rss></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 強力驅動</span>
<span class=division>|</span>
<span class=theme-info>主題 -
<a class=theme-link href=https://github.com/huanlin/hugo-theme-even-more>Even More</a></span>
<span class=copyright-year>&copy;
2016 -
2024
<span class=heart><i class="iconfont icon-heart"></i></span><span class=author>Yowko Tsai</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src="https://blog.yowko.com/lib/highlight/highlight.pack.js?v=20171001"></script><script type=text/javascript src=https://blog.yowko.com/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=https://blog.yowko.com/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=https://blog.yowko.com/lib/fancybox/jquery.fancybox-3.1.20.min.js></script><script type=text/javascript src=https://blog.yowko.com/lib/instantclick/instantclick-3.0.1.min.js data-no-instant></script><script type=text/javascript src="https://blog.yowko.com/dist/even.min.js?v=3.2.0"></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','G-7PF6W2W48Y','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>